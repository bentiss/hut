// THIS FILE IS GENERATED, DO NOT EDIT

//! A wrapper around the [HID Usage Tables (HUT)](https://usb.org/document-library/hid-usage-tables-15).
//! Note that this module is created through code generation.
//!
//! In this document and unless stated otherwise, a reference to "section a.b.c" refers to the
//! [HID Device Class Definition for HID 1.11](https://www.usb.org/document-library/device-class-definition-hid-111).
//!
//! # Terminology
//!
//! See Section 5.5: a HID Usage is a 32 bit value comprising of a 16-bit Usage
//! Page and a 16-bit Usage ID.
//!
//! In this module:
//! - "Usage Page" refers to the 16-bit value. Where the Usage Page is converted
//!   to or from a 32-bit value the Usage Page is in the upper 16 bits of that value and
//!   the lower 16 bits are ignored or set to zero.
//! - "Usage ID" refers to the 16-bit value. Where the Usage ID is converted to
//!   or from a 32-bit value the Usage is in the lower 16 bits of that value and !   the upper 16 bits are ignored or set to zero.
//! - "Usage" refers to the 32-bit value comprising a Usage Page and a Usage.
//!
//! All defined [Usage]s and [UsagePage] implement [AsUsagePage] and (if applicable) [AsUsage] as
//! well as the [`From<u16>`](From), [`From<u32>`](From) and [`TryFrom<u16>`](TryFrom) conversions so that:
//! ```
//! # use hut::*;
//! let hid_usage_page: u16 = 0x01; // Generic Desktop
//! let hid_usage_id: u16 = 0x02; // Mouse
//! let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;
//!
//! // Convert to and fro the Usage either via [u32] or the [AsUsage] trait
//! let u = GenericDesktop::Mouse;
//! assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::GenericDesktop {usage: u}));
//! assert_eq!(u32::from(&u), hid_usage);
//! assert_eq!(u.usage_value(), hid_usage);
//!
//! // Convert to and fro the UsageID either via u16 or the AsUsage trait
//! assert_eq!(hid_usage_id, u16::from(&u));
//! assert_eq!(hid_usage_id, u.usage_id_value());
//!
//! // Extract the Usage Page from  Usage enum value
//! assert!(matches!(UsagePage::from(&u), UsagePage::GenericDesktop));
//! let up = UsagePage::from(&u);
//!
//! // Get the Usage Page numeric value is via the [AsUsagePage]
//! assert_eq!(hid_usage_page, u16::from(&up));
//! assert_eq!(hid_usage_page, up.usage_page_value());
//! ```
//!
//! # Generated Usage Pages 
//!
//! The HUT differ between "Defined" and "Generated" Usage Pages. The former define Usage ID values
//! and their meanings, the latter define a Usage ID range, with the actual Usage ID simply 
//! referring to "nth thing in this usage page". One example for this is the Button Usage Page
//! (0x09) where a Usage ID of 3 means "Button 3".
//!
//! Unlike Defined Usage Pages Generated Usage Pages these need to be destructured in `match`
//! statements.
//!
//! The following usage pages are Generated:
{% for usage_page in usage_pages %}
{% if usage_page.usage_page_type == "Generated" %}
//!   - {{usage_page.name}} ({{usage_page.value}}) - see [{{usage_page.name}}]
{% endif %}
{% endfor %}
//!
//! A further special case of this is the [Unicode] usage page which is not in the HUT
//! document and was inserted during code generation.
//!
//! # Vendor Defined Usage Pages (0xFF00 to 0xFFFF)
//!
//! [Vendor Defined Usage Pages](VendorDefinedPage) and [Usages](VendorDefinedPage::VendorUsage) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Renames
//!
//! For technical reasons, spaces, (` `), dashes (`-`), and slashes (`/`) are
//! stripped out of Usage Page and Usage names. The string representation via
//! the `Display` trait will have the unmodified value.
//!
//! Usage Pages and Usages starting with a number are translated into their
//! English word, for example [GamingControls::ThreeDGameController]. Numbers
//! inside a word are left as-is.

#![allow(clippy::identity_op, clippy::eq_op, clippy::match_single_binding)]

use std::fmt;
use std::ops::BitOr;
use thiserror::Error;

// use crate::Usage as HidUsage;

#[derive(Error, Debug)]
pub enum HutError {
    #[error("Unknown Usage Page {usage_page}")]
    UnknownUsagePage { usage_page: u16 },
    #[error("Invalid Vendor Page {vendor_page}")]
    InvalidVendorPage { vendor_page: u16 },
    #[error("Unknown Usage")]
    UnknownUsage,
}

type Result<T> = std::result::Result<T, HutError>;

/// A trait to return the Usage and Usage ID as numeric value
pub trait AsUsage {
    fn usage_value(&self) -> u32;
    fn usage_id_value(&self) -> u16;
}

/// A trait to return the Usage Page as numeric value
pub trait AsUsagePage {
    /// Returns the 16 bit Usage Page value
    fn usage_page_value(&self) -> u16;
}

/// A HID UsagePage, see section 5.5. This represents the upper 16 bits in the
/// 32-bit
///
/// Note: this enum is generated from the HUT documents.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum UsagePage {
    {% for usage_page in usage_pages %}
    /// Usage Page `0x{{ '%X' % usage_page.value }}`: "{{usage_page.printable}}",
    /// see [{{usage_page.name}}].
    {{usage_page.name}},
    {% endfor %}
    /// The Vendor Defined Pages, range `0xFF00 - 0xFFFF`. See [VendorDefinedPage].
    VendorDefinedPage { vendor_page: VendorPage },
}

/// Represents a Vendor Defined Page number value of in the range 
/// 0xFF00 to 0xFFFF, inclusive. See [VendorDefinedPage].
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct VendorPage(u16);

impl From<&VendorPage> for VendorPage {
    fn from(v: &VendorPage) -> VendorPage {
        VendorPage(v.0)
    }
}

impl From<&VendorPage> for u16 {
    fn from(v: &VendorPage) -> u16 {
        v.0
    }
}

impl From<VendorPage> for u16 {
    fn from(v: VendorPage) -> u16 {
        u16::from(&v)
    }
}

impl From<&VendorPage> for u32 {
    fn from(v: &VendorPage) -> u32 {
        (v.0 as u32) << 16
    }
}

impl From<VendorPage> for u32 {
    fn from(v: VendorPage) -> u32 {
        u32::from(&v)
    }
}

impl TryFrom<u16> for VendorPage {
    type Error = HutError;

    fn try_from(v: u16) -> Result<VendorPage> {
        match v {
            p @ 0xff00..=0xffff => Ok(VendorPage(p)),
            n => Err(HutError::InvalidVendorPage { vendor_page: n }),
        }
    }
}

impl TryFrom<u32> for VendorPage {
    type Error = HutError;

    fn try_from(v: u32) -> Result<VendorPage> {
        VendorPage::try_from((v >> 16) as u16)
    }
}

impl UsagePage {
    /// Returns the Usage Page for the given Usage Page value. This is the
    /// 16-bit Usage Page value only, not the full 32-bit Usage.
    ///
    /// The returned value is always the "Undefined" usage of the matching
    /// Usage Page.
    pub fn from_usage_page_value(usage_page: u16) -> Result<UsagePage> {
        UsagePage::try_from(usage_page)
    }

    /// Returns the Usage Page for the given Usage numeric value. The Usage Page
    /// must be in the upper 16 bits of the `usage` value and the lower 16 bits
    /// are ignored.
    pub fn from_usage_value(usage: u32) -> Result<UsagePage> {
        let up: u16 = (usage >> 16) as u16;
        UsagePage::try_from(up)
    }

    /// Returns the 16-bit value for this Usage Page.
    pub fn usage_page(&self) -> u16 {
        u16::from(self)
    }

    /// Returns the 32-bit Usage that is this Usage Page combined with
    /// the 16 bits Usage ID.
    pub fn to_usage_from_value(&self, usage: u16) -> Result<Usage> {
        let up: u32 = (self.usage_page() as u32) << 16;
        let u: u32 = usage as u32;
        Usage::try_from(up | u)
    }

    pub fn to_usage(&self, usage: u16) -> Result<Usage> {
        let up: u32 = (self.usage_page() as u32) << 16;
        let u: u32 = usage as u32;
        Usage::try_from(up | u)
    }
}

impl AsUsagePage for UsagePage {
    /// Returns the 16 bit Usage Page value of this Usage Pagg
    fn usage_page_value(&self) -> u16 {
        u16::from(self)
    }
}

{% for usage_page in usage_pages %}
{% if usage_page.usage_page_type == "Defined" %}
/// *Usage Page `0x{{ '%X' % usage_page.value }}`: "{{usage_page.printable}}"*
///
/// **This enum is autogenerated from the HID Usage Tables**.
{% if usage_page.usages | length() >= 2 %}
/// ```
/// # use hut::*;
/// let u1 = Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage_page.usages[1].name}} };
/// let u2 = Usage::new_from_page_and_id(0x{{'%X' % usage_page.value}}, 0x{{'%X' % usage_page.usages[1].value}}).unwrap();
/// let u3 = Usage::from({{usage_page.name}}::{{usage_page.usages[1].name}});
/// assert_eq!(u1, u2);
/// assert_eq!(u1, u3);
///
/// assert_eq!(0x{{'%X' % usage_page.value}}, u1.usage_page_value());
/// assert_eq!(0x{{'%X' % usage_page.usages[1].value}}, u1.usage_id_value());
/// assert_eq!((0x{{'%X' % usage_page.value}} << 16) | 0x{{'%X' % usage_page.usages[1].value}}, u1.usage_value());
/// ```
{% endif %}
///
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum {{usage_page.name}} {
{% for usage in usage_page.usages %}
    /// Usage ID `0x{{ '%X' % usage.value}}`: "{{usage.printable}}"
    {{ usage.name }},
{% endfor %}
}

impl fmt::Display for {{usage_page.name}} {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage in usage_page.usages %}
            {{usage_page.name}}::{{usage.name}} => "{{usage.printable}}",
{% else %}
            _ => "",
{% endfor %}
        };
        write!(f, "{name}")
    }
}

{% endif %}{# if usage_page.usage_page_type == Defined ... #}
{% if usage_page.usage_page_type == "Generated" %}
/// *Usage Page `0x{{ '%X' % usage_page.value }}`: "{{usage_page.printable}}"*
///
/// **This enum is autogenerated from the HID Usage Tables**.
///
/// This Usage Page is generated, not defined, any Usage IDs in this Usage
/// Page are simply the {{usage_page.name_prefix|lower}} number.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum {{usage_page.name}} {
    {{usage_page.name}} {
        {{usage_page.name_prefix|lower}}: u16,
    }
}

impl fmt::Display for {{usage_page.name}} {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            {{usage_page.name}}::{{usage_page.name}} { {{usage_page.name_prefix|lower}} } => format!("{{usage_page.name_prefix}} { {{-usage_page.name_prefix|lower-}} }"),
        };
        write!(f, "{name}")
    }
}

{% endif %}{# if usage_page.usage_page_type == Generated ... #}
{% endfor %}

{% for usage_page in usage_pages %}
impl AsUsage for {{usage_page.name}} {
    /// Returns the 32 bit Usage value of this Usage
    fn usage_value(&self) -> u32 {
        u32::from(self)
    }

    /// Returns the 16 bit Usage ID value of this Usage
    fn usage_id_value(&self) -> u16 {
        u16::from(self)
    }
}

impl AsUsagePage for {{usage_page.name}} {
    /// Returns the 16 bit value of this UsagePage
    ///
    /// This value is `0x{{ '%X' % usage_page.value }}` for [{{usage_page.name}}]
    fn usage_page_value(&self) -> u16 {
        let up = UsagePage::from(self);
        u16::from(up)
    }
}

impl From<&{{usage_page.name}}> for u16 {
    fn from(up: &{{usage_page.name}}) -> u16 {
        match *up {
        {% if usage_page.usage_page_type == "Defined" %}
            {% for usage in usage_page.usages %}
            {{usage_page.name}}::{{usage.name}} => {{usage.value}},
            {% endfor %}
        {% endif %}
        {% if usage_page.usage_page_type == "Generated" %}
            {{usage_page.name}}::{{usage_page.name}} { {{usage_page.name_prefix|lower}} } => {{usage_page.name_prefix|lower}},
        {% endif %}
        }
    }
}

impl From<{{usage_page.name}}> for u16 {
    fn from(up: {{usage_page.name}}) -> u16 {
        u16::from(&up)
    }
}

impl From<&{{usage_page.name}}> for u32 {
    fn from(usage: &{{usage_page.name}}) -> u32 {
        let up = UsagePage::from(usage);
        let up = (u16::from(&up) as u32) << 16;
        let id = u16::from(usage) as u32;
        up | id
    }
}

impl From<&{{usage_page.name}}> for UsagePage {
    fn from(_up: &{{usage_page.name}}) -> UsagePage {
        UsagePage::{{usage_page.name}}
    }
}

impl From<{{usage_page.name}}> for UsagePage {
    fn from(up: {{usage_page.name}}) -> UsagePage {
        UsagePage::from(&up)
    }
}

impl From<&{{usage_page.name}}> for Usage {
    fn from(u: &{{usage_page.name}}) -> Usage {
        Usage::try_from(u32::from(u)).unwrap()
      }
}

impl From<{{usage_page.name}}> for Usage {
    fn from(u: {{usage_page.name}}) -> Usage {
        Usage::from(&u)
      }
}

impl BitOr<u16> for {{usage_page.name}} {
    type Output = Usage;

    /// A convenience function to combine a Usage Page with
    /// a value.
    ///
    /// This function panics if the Usage ID value results in
    /// an unknown Usage. Where error checking is required,
    /// use [UsagePage::to_usage].
    fn bitor(self, usage: u16) -> Usage {
        let up = u16::from(self) as u32;
        let u = usage as u32;
        Usage::try_from(up | u).expect("Invalid Usage ID for this Usage Page")
    }
}

{% endfor %}


/// *Usage Page `0xFF00` to `0xFFFF`: The Vendor Defined Pages*
///
/// This Usage Page has no named Usage IDs, any Usages in this Usage Page are
/// private to a vendor implementation.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum VendorDefinedPage {
    Undefined,
    VendorUsage { usage_id: u16 },
}

impl fmt::Display for VendorDefinedPage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            VendorDefinedPage::Undefined => "Vendor Usage Undefined".to_string(),
            VendorDefinedPage::VendorUsage { usage_id } => {
                format!("Vendor Usage 0x{usage_id:02x}")
            }
        };
        write!(f, "{name}")
    }
}

impl From<&Usage> for UsagePage {
    fn from(usage: &Usage) -> UsagePage {
        match usage {
{% for usage_page in usage_pages %}
            Usage::{{usage_page.name}} { .. } => UsagePage::{{usage_page.name}},
{% endfor %}
            Usage::VendorDefinedPage { vendor_page, .. } => UsagePage::VendorDefinedPage { vendor_page: *vendor_page },
        }
    }
}

impl From<&UsagePage> for u16 {
    /// Returns the UsagePage as 16-bit value. This is equivalent to the
    /// upper 16 bits of a full 32-bit Usage value shifted down.
    fn from(usage_page: &UsagePage) -> u16 {
        match usage_page {
{% for usage_page in usage_pages %}
            UsagePage::{{usage_page.name}} { .. } => {{usage_page.value}},
{% endfor %}
            UsagePage::VendorDefinedPage { .. } => 0xff00,
        }
    }
}

impl From<UsagePage> for u16 {
    fn from(usage_page: UsagePage) -> u16 {
        u16::from(&usage_page)
    }
}

impl TryFrom<u16> for UsagePage {
    type Error = HutError;

    fn try_from(usage_page: u16) -> Result<UsagePage> {
        match usage_page {
{% for usage_page in usage_pages %}
            {{usage_page.value}} => Ok(UsagePage::{{usage_page.name}}),
{% endfor %}
            page @ 0xff00..=0xffff => Ok(UsagePage::VendorDefinedPage { vendor_page: VendorPage(page) }),
            n => Err(HutError::UnknownUsagePage { usage_page: n }),
        }
    }
}

impl fmt::Display for UsagePage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name: String = match self {
{% for usage_page in usage_pages %}
            UsagePage::{{usage_page.name}} => "{{usage_page.printable}}".into(),
{% endfor %}
            UsagePage::VendorDefinedPage { vendor_page, .. } => format!("Vendor Defined Page {:04X}", u16::from(vendor_page)),
        };
        write!(f, "{name}")
    }
}

/// An enum wrapping all known Usages in the HUT.
/// ```
/// # use hut::*;
/// let u1 = Usage::GenericDesktop { usage: GenericDesktop::Mouse};
/// let u2 = Usage::new_from_page_and_id(0x01, 0x02).unwrap();
/// let u3 = Usage::from(GenericDesktop::Mouse);
/// assert_eq!(u1, u2);
/// assert_eq!(u1, u3);
///
/// assert_eq!(0x1, u1.usage_page_value());
/// assert_eq!(0x2, u1.usage_id_value());
/// assert_eq!(0x1 << 16 | 0x2, u1.usage_value());
/// ```
/// Note: this enum is generated from the HUT documents.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum Usage {
    {% for usage_page in usage_pages %}
    /// "{{usage_page.printable}}"
    {{usage_page.name}} {
        usage: {{usage_page.name}},
    },
    {% endfor %}
    VendorDefinedPage { 
        vendor_page: VendorPage,
        usage: VendorDefinedPage,
    },
}

impl Usage {
    pub fn new_from_page_and_id(usage_page: u16, usage_id: u16) -> Result<Usage> {
        Usage::try_from((usage_page as u32) << 16 | usage_id as u32)
    }
}

impl AsUsage for Usage {
    /// Returns the 32 bit Usage value for this usage.
    fn usage_value(&self) -> u32 {
        self.into()
    }

    /// Returns the 16-bit Usage ID value for this usage.
    fn usage_id_value(&self) -> u16 {
        self.into()
    }
}

impl PartialEq for Usage {
    fn eq(&self, other: &Self) -> bool {
        u32::from(self) == u32::from(other)
    }
}

impl AsUsagePage for Usage {
    fn usage_page_value(&self) -> u16 {
        UsagePage::from(self).into()
    }
}

impl fmt::Display for Usage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage_page in usage_pages %}
            Usage::{{usage_page.name}} { usage } => format!("{usage}"),
{%  else %}
            _ => "".into(),
{% endfor %}
            Usage::VendorDefinedPage { usage, .. } => format!("{usage}"),
        };
        write!(f, "{name}")
    }
}

impl From<&Usage> for u16 {
    fn from(usage: &Usage) -> u16 {
        let u: u32 = u32::from(usage);
        (u & 0xFFFF) as u16
    }
}

impl From<Usage> for u16 {
    fn from(usage: Usage) -> u16 {
        u16::from(&usage)
    }
}

impl From<&Usage> for u32 {
    fn from(usage: &Usage) -> u32 {
        match usage {
{% for usage_page in usage_pages %}
{% for usage in usage_page.usages %}
            Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage.name}} } => {{usage_page.value}} << 16 | {{usage.value}},
{% endfor  %}
{% endfor  %}
            Usage::VendorDefinedPage { vendor_page, usage: VendorDefinedPage::Undefined } => (u16::from(vendor_page) as u32) << 16,
            Usage::VendorDefinedPage { vendor_page, usage: VendorDefinedPage::VendorUsage { usage_id } } => (u16::from(vendor_page) as u32) << 16 | *usage_id as u32,
            _ => panic!("Unhandled usage {usage:?}"),
        }
    }
}

//impl TryFrom<&HidUsage> for Usage {
//    type Error = HutError;
//
//    fn try_from(usage: &HidUsage) -> Result<Usage> {
//        let up = u16::from(usage.usage_page);
//        let u = u16::from(usage.usage_id);
//        Usage::new_from_page_and_id(up, u)
//    }
//}

impl TryFrom<u32> for Usage {
    type Error = HutError;

    fn try_from(up: u32) -> Result<Usage> {
        match (up >> 16, up & 0xFFFF) {
{% for usage_page in usage_pages %}
{% for usage in usage_page.usages %}
            ({{usage_page.value}},  {{usage.value}}) => Ok(Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage.name}} }),
{% endfor  %}
{% endfor  %}
            (p @ 0xff00..=0xffff, n) => Ok(Usage::VendorDefinedPage {
                vendor_page: VendorPage(p as u16),
                usage: VendorDefinedPage::VendorUsage { usage_id: n as u16 }
            }),
            (_, _) => Err(HutError::UnknownUsage),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn conversions() {
        let hid_usage_page: u16 = 0x01; // Generic Desktop
        let hid_usage_id: u16 = 0x02; // Mouse
        let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;

        let u = GenericDesktop::Mouse;
        // 32 bit usage to enum
        assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::GenericDesktop {usage: _}));

        // Usage to u32
        assert_eq!(u32::from(&u), hid_usage);
        assert_eq!(u.usage_value(), hid_usage);

        // Usage to u16 usage_id
        assert_eq!(hid_usage_id, u16::from(&u));
        assert_eq!(hid_usage_id, u.usage_id_value());

        // Usage to UsagePage
        assert!(matches!(UsagePage::from(&u), UsagePage::GenericDesktop));

        // UsagePage to u16
        let up = UsagePage::from(&u);
        assert_eq!(hid_usage_page, u16::from(&up));

        // UsagePage to u16 via AsUsagePage trait
        assert_eq!(hid_usage_page, up.usage_page_value());
    }

    #[test]
    fn buttons() {
        let hid_usage_page: u16 = 0x9;
        let hid_usage_id: u16 = 0x5;
        let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;

        let u = Button::Button { button: 5 };
        assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::Button { usage: _ }));

        // Usage to u32
        assert_eq!(u32::from(&u), hid_usage);
        assert_eq!(u.usage_value(), hid_usage);

        // Usage to u16 usage_id
        assert_eq!(hid_usage_id, u16::from(&u));
        assert_eq!(hid_usage_id, u.usage_id_value());

        // Usage to UsagePage
        assert!(matches!(UsagePage::from(&u), UsagePage::Button));

        // UsagePage to u16
        let up = UsagePage::from(&u);
        assert_eq!(hid_usage_page, u16::from(&up));

        // UsagePage to u16 via AsUsagePage trait
        assert_eq!(hid_usage_page, up.usage_page_value());
    }

    #[test]
    fn ordinals() {
        let hid_usage_page: u16 = 0xA;
        let hid_usage_id: u16 = 0x8;
        let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;

        let u = Ordinal::Ordinal { instance: 8 };
        assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::Ordinal { usage: _ }));

        // Usage to u32
        assert_eq!(u32::from(&u), hid_usage);
        assert_eq!(u.usage_value(), hid_usage);

        // Usage to u16 usage_id
        assert_eq!(hid_usage_id, u16::from(&u));
        assert_eq!(hid_usage_id, u.usage_id_value());

        // Usage to UsagePage
        assert!(matches!(UsagePage::from(&u), UsagePage::Ordinal));

        // UsagePage to u16
        let up = UsagePage::from(&u);
        assert_eq!(hid_usage_page, u16::from(&up));

        // UsagePage to u16 via AsUsagePage trait
        assert_eq!(hid_usage_page, up.usage_page_value());
    }
}
